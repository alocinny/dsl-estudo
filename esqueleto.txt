# 1. IMPORTS (Sempre igual)
from antlr4 import *
from NomeDaGramaticaLexer import *
from NomeDaGramaticaParser import *

# 2. MEM칍RIA (Dicion치rio ou Lista)
# Interpretador -> Guarda valores (x=10)
# Sem칙ntico -> Guarda tipos (x="int")
memoria = {} 

# 3. FUN칂츾O C칄REBRO (Recursiva)
def processa(t):
    match t:
        # --- CASO N칍 PAI (Ex: Programa, Lista de Comandos) ---
        case NomeDaGramaticaParser.ProgramaContext():
            for filho in t.getChildren(): # Visita todos
                processa(filho)
                
        # --- CASO COMANDO/A칂츾O (Ex: Atribui칞칚o, Declara칞칚o) ---
        case NomeDaGramaticaParser.ComandoContext():
            # A. Extrai dados (Tokens)
            id = t.ID().getText()
            valor = processa(t.expressao()) # Desce na 치rvore se precisar
            
            # B. FAZ A M츼GICA (Aqui muda conforme a quest칚o)
            # ... recheio ...
            
        # --- CASO FOLHA/VALOR (Ex: N칰mero, String) ---
        case NomeDaGramaticaParser.NumContext():
            return float(t.NUM().getText()) # Retorna o valor limpo

        case _:
            pass # Ignora lixo

---

Como adaptar o "Recheio" (B. Faz a M치gica)
Dependendo do que a quest칚o pedir, voc칡 muda apenas o passo B.

1. Se pedir INTERPRETADOR (Rob칪, Calculadora)
Objetivo: Rodar agora.

A칞칚o: Calcular e atualizar vari치vel.

Exemplo:

# Recheio:
resultado = valor1 + valor2
memoria[id] = resultado
print(resultado)
2. Se pedir ANALISADOR SEM츽NTICO (Tipos, Vari치veis n칚o declaradas)
Objetivo: Achar erro.

A칞칚o: Verificar if e dar raise Exception.

Exemplo:

# Recheio:
if id in memoria:
    raise Exception(f"Erro: Vari치vel {id} j치 declarada!")
memoria[id] = "int" # Guarda s칩 o tipo, n칚o o valor
3. Se pedir COMPILADOR (Gerar c칩digo)
Objetivo: Escrever print.

A칞칚o: Dar print em strings de comando.

Exemplo:

# Recheio:
processa(t.expressao()) # Gera c칩digo dos filhos primeiro
print(f"STORE {id}")    # Imprime instru칞칚o da m치quina

=========================================================================================================

# 1. MEM칍RIA DO FISCAL
tabela = {}  # Pode ser um set() se s칩 precisar checar nomes

def analisa(t):
    match t:
        # --- CASO 1: DECLARA칂츾O (Nascer) ---
        # Ex: "var x;" ou "Ingrediente Farinha"
        case Parser.DeclaracaoContext():
            nome = t.ID().getText()
            tipo = t.TIPO().getText() # Se houver tipo
            
            # REGRA: N칚o pode nascer duas vezes
            if nome in tabela:
                raise Exception(f"Erro: '{nome}' j치 existe!")
            
            # A칂츾O: Registra na tabela
            tabela[nome] = tipo # ou tabela.add(nome)

        # --- CASO 2: USO (Viver) ---
        # Ex: "x = 10" ou "Adicione Farinha"
        case Parser.UsoContext():
            nome = t.ID().getText()
            
            # REGRA: Tem que ter nascido antes
            if nome not in tabela:
                raise Exception(f"Erro: '{nome}' n칚o foi declarado!")

        # --- CASO 3: OPERA칂츾O (Misturar Tipos) ---
        # Ex: "10 + x"
        case Parser.SomaContext():
            # No sem칙ntico, a gente "calcula" o TIPO, n칚o o valor
            tipo_esq = analisa(t.esq()) # Retorna 'int'
            tipo_dir = analisa(t.dir()) # Retorna 'int' ou 'string'
            
            # REGRA: Tipos iguais
            if tipo_esq != tipo_dir:
                raise Exception("Erro: N칚o pode somar banana com laranja!")
            
            return tipo_esq # A soma de int+int resulta em 'int'

        # --- CASO PADR츾O (N칩s pais) ---
        case Parser.ProgramaContext():
            for filho in t.getChildren():
                analisa(filho)
                
        # --- CASO FOLHA (Valor primitivo) ---
        case Parser.NumContext():
            return 'int' # Retorna o R칩tulo, n칚o o valor!

---
Ingredientes (O que voc칡 precisa ter)
Tabela de S칤mbolos (Mem칩ria):

No Interpretador: x = 10 (Guarda valor).

No Sem칙ntico: x = 'int' ou apenas ['x', 'y'] (Guarda exist칡ncia ou tipo).

O Fiscal (Fun칞칚o Recursiva):

Visita os n칩s.

N칚o retorna valor num칠rico.

Retorna TIPO (ex: "int", "string") ou Nada.

As Regras (Os ifs):

Vari치vel n칚o declarada.

Vari치vel duplicada.

Tipos incompat칤veis (somar texto com n칰mero).
---
Resumo para levar na cabe칞a

Viu Declara칞칚o? -> if nome in tabela: ERRO -> tabela[nome] = tipo

Viu Uso? -> if nome not in tabela: ERRO

Viu Express칚o? -> Pegue os tipos dos filhos (tipo1 = analisa(f1)) -> if tipo1 != tipo2: ERRO

-------------------------------------------------------

游닇 A Receita (Decore isso)
Ingredientes Globais:

mapa = {}: Um caderninho para anotar onde cada vari치vel mora (ex: x -> endere칞o 0).

end = 0: O contador para o pr칩ximo endere칞o livre.

Modo de Preparo (Fun칞칚o gera):

Viu N칰mero (10)?

Grita: PUSHI 10 (Empilha o valor).

Viu Vari치vel (x) para LER?

Descobre o endere칞o (ex: 0).

Grita: PUSHI 0 (Empilha endere칞o).

Grita: LOAD (Troca endere칞o pelo valor).

Viu Conta (+, -, *)?

Cozinha o lado Esquerdo (gera(esq)).

Cozinha o lado Direito (gera(dir)).

Grita a opera칞칚o: ADD, SUB, MUL ou DIV.

Viu Atribui칞칚o (x = ...)?

Cozinha o lado Direito (o valor da conta) INTEIRO primeiro.

Descobre o endere칞o de x (ex: 0).

Grita: STORE 0 (Guarda o topo da pilha no endere칞o 0).